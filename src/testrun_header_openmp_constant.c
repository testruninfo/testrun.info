/*
 *      Definition of the header constant for the header file content. 
 */

static char *testrun_header_openmp = 
"/***\n"
"        ------------------------------------------------------------------------\n"
"\n"
"        Copyright 2017 Markus Toepfer\n"
"\n"
"        Licensed under the Apache License, Version 2.0 (the \"License\");\n"
"        you may not use this file except in compliance with the License.\n"
"        You may obtain a copy of the License at\n"
"\n"
"                http://www.apache.org/licenses/LICENSE-2.0\n"
"\n"
"        Unless required by applicable law or agreed to in writing, software\n"
"        distributed under the License is distributed on an \"AS IS\" BASIS,\n"
"        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
"        See the License for the specific language governing permissions and\n"
"        limitations under the License.\n"
"\n"
"        This file is part of the testrun project. http://testrun.info\n"
"\n"
"        ------------------------------------------------------------------------\n"
" *//**\n"
"\n"
"        @file           testrun_openmp.h\n"
"        @author         Markus Toepfer\n"
"        @date           2017-11-17\n"
"\n"
"        @brief          Serial and parallel test executing framework with or\n"
"                        without assertion based testing.\n"
"\n"
"        This is an enhanced and compatible version of the initial idea of an\n"
"        small and simple C89 compatible C unittest header (@see testrun.h)\n"
"\n"
"        For parallel test runs, this framework makes use of OpenMP. Therefore\n"
"        the code MUST be compiled with -fopenmp, otherwise the code will stay\n"
"        unparallel and execution sequential.\n"
"\n"
"        @NOTE to use all provided functionality of the header, tests SHOULD be\n"
"        compiled using:\n"
"\n"
"                -fopenmp    (parallel execution) and\n"
"                -rdynamic   (function name backtracing)\n"
"\n"
"        @NOTE Valgrind based file execution in libomp based OpenMP scenarios\n"
"        may not work, @see docs/valgrind/openMP/README.MD for additional\n"
"        information.\n"
"\n"
"        ------------------------------------------------------------------------\n"
" */\n"
"\n"
"#ifndef testrun_openmp_h\n"
"#define testrun_openmp_h\n"
"\n"
"#include <omp.h>                /* OpenMP parallel (part of GCC, Clang/LLVM) */\n"
"\n"
"#include <stdbool.h>            /* C99 */\n"
"#include <stdint.h>             /* C99 */\n"
"\n"
"#include <unistd.h>             /* C89/C90 */\n"
"#include <stdlib.h>             /* C89/C90 */\n"
"#include <stdio.h>              /* C89/C90 */\n"
"#include <string.h>             /* C89/C90 */\n"
"#include <errno.h>              /* C89/C90 */\n"
"#include <time.h>               /* C89/C90 */\n"
"#include <assert.h>             /* C89/C90 */\n"
"\n"
"#if defined(__GLIBC__)\n"
"#include <execinfo.h>           /* Gnulib backtrace of function pointer names */\n"
"#endif\n"
"\n"
"#define TESTRUN_DEFAULT_CLUSTER_MAX 1000\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Error initialization of none error.\n"
"*/\n"
"#define testrun_errno() \\\n"
"        (errno == 0 ? \"NONE\" :  strerror(errno))\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Log a failure. Failure: Inability to perform a function as expected.\n"
"*/\n"
"#define testrun_log_failure(msg, ...) \\\n"
"        fprintf(stderr, \"\\t[FAIL]\\t%s line:%d errno:%s message: \" msg \"\\n\",\\\n"
"        __FUNCTION__, __LINE__, testrun_errno(), ##__VA_ARGS__)\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Log an error. Error: Difference between expected and actual result.\n"
"*/\n"
"#define testrun_log_error(msg, ...) \\\n"
"        fprintf(stderr, \"\\t[ERROR]\\t%s line:%d errno:%s message: \" msg \"\\n\",\\\n"
"        __FUNCTION__, __LINE__, testrun_errno(), ##__VA_ARGS__)\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"#define testrun_log_success(msg, ...) \\\n"
"        fprintf(stdout, \"\\t[OK] \\t%s \" msg \"\\n\", __FUNCTION__, ##__VA_ARGS__)\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"#define testrun_log(msg, ...) \\\n"
"        fprintf(stdout, \"\\t\" msg \"\\n\", ##__VA_ARGS__)\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"#define testrun_log_function_info(msg, ...) \\\n"
"        fprintf(stdout, \"\\t[INFO] \\t%s line:%d message: \" msg \"\\n\", \\\n"
"                __FUNCTION__, __LINE__, ##__VA_ARGS__)\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"#define testrun_log_clock(start, end) \\\n"
"        fprintf(stdout, \"\\tClock ticks function: ( %s ) | %f | %.0f ms \\n\",\\\n"
"        __func__, \\\n"
"        ((double)(end - start)) / CLOCKS_PER_SEC, \\\n"
"        (((double)(end - start)) / CLOCKS_PER_SEC ) * 1000)\n"
"\n"
"/*----------------------------------------------------------------------------\n"
" *\n"
" *      Block of supporting MACROS for assert based testing.\n"
" *\n"
" *      Assert based testing is build around the principle to bundle and\n"
" *      define some testcases, which will be run in series.\n"
" *      Within the testcases testrun_assert(), or assert() may be used to\n"
" *      stop testing.\n"
" *\n"
" *      -----------------------------------------------------------------\n"
" *\n"
" *      Example usage:\n"
" *\n"
" *      int testcase1_function(){\n"
" *              assert(true);\n"
" *              return testrun_log_success();\n"
" *      }\n"
" *\n"
" *      int testcase1_function(){\n"
" *              testrun_assert(true, \"additional info an failure.\");\n"
" *              return testrun_log_success();\n"
" *      }\n"
" *\n"
" *      int testseries() {\n"
" *\n"
" *              testrun_init();\n"
" *\n"
" *              testrun_test(testcase1_function);\n"
" *              testrun_test(testcase2_function);\n"
" *\n"
" *              return testrun_counter;\n"
" *      }\n"
" *\n"
" *      testrun_run(testseries);\n"
" *\n"
" *----------------------------------------------------------------------------*/\n"
"\n"
"#define testrun_init()  \\\n"
"        int result = 0; \\\n"
"        int testrun_counter = 0;\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Wrapper around assert, which adds a message level to assert, to provide\n"
"        additional and related information e.g. a failure description.\n"
"\n"
"        @param test     an actual test case e.g. (1 == 0)\n"
"        @param message  additional message to log e.g. \"Failure: 1 is not one\"\n"
"*/\n"
"#define testrun_assert(test, ... )\\\n"
"        if (!(test)) { testrun_log_error(__VA_ARGS__); assert(test); }\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Run a single test (execute a function pointer. Runs a test function.\n"
"        On non negative return value of the function run, a testrun_counter\n"
"        is increased, on negative result, the negative result will be returned.\n"
"\n"
"        @param test     function pointer of the test to run\n"
"        @NOTE           The surrounding block is left on negative result of the\n"
"                        function pointer execution.\n"
"*/\n"
"#define testrun_test(test)\\\n"
"        result = test(); testrun_counter++; if (result < 0) return result;\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Runs a function pointer, which SHALL contain the test function pointers\n"
"        to run. The function pointer is wrapped in a main procedure, which and\n"
"        allows indepentent testruns of the input testcluster over external\n"
"        execution.\n"
"\n"
"        A clock will be started, as soon as the main is executed and the the\n"
"        time is stopped again, at the end of the execution. The difference\n"
"        will be printed and is the runtime of the whole input testcluster.\n"
"\n"
"        A run will fail, as soon as one of the tests in the testcluster fails.\n"
"        (Fail on first) or will run all functions dependent on the testsetup.\n"
"\n"
"        @param testcluster      function pointer to be executed.\n"
"*/\n"
"#define testrun_run(testcluster) int main(int argc, char *argv[]) {\\\n"
"        argc = argc;\\\n"
"        clock_t start1_t, end1_t; \\\n"
"        start1_t = clock(); \\\n"
"        testrun_log(\"\\ntestrun\\t%s\", argv[0]);\\\n"
"        int64_t result = testcluster();\\\n"
"        if (result > 0) \\\n"
"                testrun_log(\"ALL TESTS RUN (%jd tests)\", result);\\\n"
"        end1_t = clock(); \\\n"
"        testrun_log_clock(start1_t, end1_t); \\\n"
"        testrun_log(\"\");\\\n"
"        result >= 0 ? exit(EXIT_SUCCESS) : exit(EXIT_FAILURE); \\\n"
"}\n"
"\n"
"/*----------------------------------------------------------------------------\n"
" *\n"
" *      Block of supporting MACROS an inline functions for sequntial and\n"
" *      parallel testing. Most of the functionality is realted to configure\n"
" *      testseries for parallel and/or sequential runs. Which functions may\n"
" *      be run as parallel tests or sequential tests, is up to the test\n"
" *      developer.\n"
" *\n"
" *      This type of testing is highly customizable and may be adapted\n"
" *      and customized by each test module implementation.\n"
" *\n"
" *      -----------------------------------------------------------------\n"
" *\n"
" *      An implementation MUST to support the testrun_fun_tests() function\n"
" *      is the implementation of the configure functions. These functions\n"
" *      define, which testseries may be run in parallel and which sequential.\n"
" *\n"
" *              bool testrun_configure_parallel(\n"
" *                      int (*testcases[])(),\n"
" *                      size_t * const start,\n"
" *                      size_t const * const max);\n"
" *\n"
" *      as well as\n"
" *\n"
" *              bool testrun_configure_sequential(\n"
" *                      int (*testcases[])(),\n"
" *                      size_t * const start,\n"
" *                      size_t const * const max);\n"
" *\n"
" *      -----------------------------------------------------------------\n"
" *\n"
" *      Example usage:\n"
" *\n"
" *      int testcase1_function(){\n"
" *              testrun(true);\n"
" *              return testrun_log_success();\n"
" *      }\n"
" *\n"
" *      int testcase1_function(){\n"
" *              testrun(true, \"additional info an failure.\");\n"
" *              return testrun_log_success();\n"
" *      }\n"
" *\n"
" *      int64_t testseries(int(*tests[])(), size_t slot, size_t max) {\n"
" *\n"
" *              testrun_init();\n"
" *\n"
" *              testrun_add(testcase1_function);\n"
" *              testrun_add(testcase2_function);\n"
" *\n"
" *              return testrun_counter;\n"
" *      }\n"
" *\n"
" *      -----------------------------------------------------------------\n"
" *\n"
" *      NOTE: Here we configure a testseries to be run sequential and parallel\n"
" *\n"
" *      bool testrun_configure_parallel(\n"
" *                      int (*testcases[])(),\n"
" *                      size_t * const start,\n"
" *                      size_t const * const max){\n"
" *\n"
" *              if (testrun_add_testcases(testcases,start,end,testseries) < 0)\n"
" *                      return false;\n"
" *\n"
" *              return true;\n"
" *\n"
" *      bool testrun_configure_sequential(\n"
" *                      int (*testcases[])(),\n"
" *                      size_t * const start,\n"
" *                      size_t const * const max){\n"
" *\n"
" *              if (testrun_add_testcases(testcases,start,end,testseries) < 0)\n"
" *                      return false;\n"
" *\n"
" *              return true;\n"
" *\n"
" *      -----------------------------------------------------------------\n"
" *\n"
" *      NOTE: This last function definition is needed to configure the\n"
" *      maximum amount of parallel and sequential tests as parameters\n"
" *      instead of a predefinition.\n"
" *\n"
" *      int64_t run_tests(){\n"
" *              return testrun_run_tests(1000,1000,false);\n"
" *      }\n"
" *\n"
" *      testrun_run(run_tests);\n"
" *\n"
" *----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        MUST be implemented to configure parallel tests.\n"
"\n"
"        @param testcases        array of function pointers\n"
"        @param start            first slot the be used in testcases\n"
"        @param max              maximum slots of testcases (last slot to be set)\n"
"        @returns                true on success, false on errror\n"
"*/\n"
"bool testrun_configure_parallel(\n"
"        int (*testcases[])(),\n"
"        size_t * const start,\n"
"        size_t const * const max);\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        MUST be implemented to configure sequential tests.\n"
"\n"
"        @param testcases        array of function pointers\n"
"        @param start            first slot the be used in testcases\n"
"        @param max              maximum slots of testcases (last slot to be set)\n"
"        @returns                true on success, false on errror\n"
"*/\n"
"bool testrun_configure_sequential(\n"
"        int (*testcases[])(),\n"
"        size_t * const start,\n"
"        size_t const * const max);\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Run a single atomar test. Return the surrounding block on error.\n"
"        This function will leave the context block running on error. The\n"
"        Mindset is a defused assert. LEAVE THE FUNCTION NOT THE PROGRAM.\n"
"\n"
"        @param test     Boolean decision input.\n"
"*/\n"
"#define testrun_check(test, ... )\\\n"
"        if (!(test)) { testrun_log_error(__VA_ARGS__);  return -1;}\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Alias to @see testrun_check.\n"
"*/\n"
"#define testrun(test, ...)\\\n"
"        testrun_check(test, __VA_ARGS__ )\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Add a new test to the tests array. This is a convinience function\n"
"        to add a function pointer to the array tests[]. This MACRO uses\n"
"        block variables **slot**, **testrun_counter**, **max** and **tests[]**.\n"
"\n"
"        @param test     function pointer to a new test to be added.\n"
"*/\n"
"#define testrun_add(test)  \\\n"
"        if (slot + testrun_counter == max) { \\\n"
"                testrun_log_failure(\"All test slots filled, \" \\\n"
"                        \"check config TESTS[MAX].\"); \\\n"
"                if (testrun_counter == 0) \\\n"
"                        return -1; \\\n"
"                return -testrun_counter; \\\n"
"        } else { \\\n"
"                tests[slot + testrun_counter] = test; \\\n"
"                testrun_counter++; \\\n"
"        }\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Array initialization to point to NULL.\n"
"\n"
"        @param array    array to be initialized\n"
"        @param start    first item to set to NULL\n"
"        @param end      last item to set to NULL\n"
"*/\n"
"#define testrun_init_testcases(array, start, end, ...) \\\n"
"        for (size_t i = start; i < end; i++ ) { array[i] = NULL; }\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Add some test cases to a testcase function pointer array, using\n"
"        a user provided function to add the testcases.\n"
"\n"
"        Function will log the result of testcases added.\n"
"\n"
"        @param tests            pointer to function pointer array\n"
"        @param last             pointer to counter of last set item\n"
"        @param max              pointer to value of max items\n"
"        @param function         function to add the tests to the array\n"
"\n"
"        @returns                negative count of testcases to add\n"
"                                positive count of added testcases\n"
" */\n"
"static inline int64_t testrun_add_testcases(\n"
"        int (*tests[])(),\n"
"        size_t * const last,\n"
"        size_t const * const max,\n"
"        int64_t (*function)(int (*tests[])(), size_t, size_t)){\n"
"\n"
"        if (!tests || !function || !last || !max)\n"
"                return -1;\n"
"\n"
"        if (*last > *max)\n"
"                return -1;\n"
"\n"
"        int64_t r = 0;\n"
"\n"
"        r = function(tests, *last, *max);\n"
"\n"
"        if (r < 0) {\n"
"\n"
"                // reinit all from last to end to NULL\n"
"                testrun_init_testcases(tests, *last, *max);\n"
"\n"
"                testrun_log_failure(\n"
"                        \"Failed to add tests to TESTS[] \"\n"
"                        \"(usage %jd/%jd)\",\n"
"                        *last, *max);\n"
"\n"
"                return -1;\n"
"\n"
"        } else {\n"
"\n"
"                *last += r;\n"
"                testrun_log_function_info(\n"
"                        \"added %jd tests to TESTS[]\"\n"
"                        \"(usage %jd/%jd)\",\n"
"                        r, *last, *max);\n"
"        }\n"
"\n"
"        return r;\n"
"\n"
"}\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Dumb the test cases to stdout.\n"
"\n"
"        To enable a backtrace with names, the file MUST be compiled with\n"
"        MODCFLAGS += -rdynamic\n"
"\n"
"        @param function         pointer to function pointer array\n"
"        @param items            amount of items in functions\n"
"        @param names            bool to try to backtrace names\n"
"        @returns                negative count of failed tests\n"
"                                positive count of run tests otherwise\n"
" */\n"
"static inline bool testrun_dump_testcases(\n"
"        int (*functions[])(),\n"
"        size_t max,\n"
"        bool names) {\n"
"\n"
"        if (!functions || max < 1)\n"
"                return false;\n"
"\n"
"        void *pointer = NULL;\n"
"\n"
"        // dump is formated to fit to standard header log and to dump 20 digits\n"
"        fprintf(stdout, \"\\t[DUMP]\\ttestcases tests[%jd]\\n\", max);\n"
"        if (names){\n"
"                #if defined(__GLIBC__)\n"
"                        fprintf(stdout, \"\\t[DUMP]\\t ... try to backtrace\\n\");\n"
"                #else\n"
"                        fprintf(stdout, \"\\t[DUMP]\\t ... names not implemented\\n\");\n"
"                #endif\n"
"        }\n"
"\n"
"        for (size_t i = 0; i < max; i++) {\n"
"\n"
"                pointer = (void*) functions[i];\n"
"\n"
"                if (names) {\n"
"                        #if defined(__GLIBC__)\n"
"                                backtrace_symbols_fd(&pointer, 1, STDOUT_FILENO);\n"
"                        #else\n"
"                                // fallback to printf\n"
"                                fprintf(stdout, \"%20jd %p \\n\", i, pointer);\n"
"                        #endif\n"
"                } else {\n"
"                        fprintf(stdout, \" %20jd %p \\n\", i, pointer);\n"
"                }\n"
"\n"
"        }\n"
"\n"
"        return true;\n"
"}\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Run a bunch of tests in parallel. This will run all configured\n"
"        tests independently and return the result of the test batch,\n"
"        once all tests are done.\n"
"\n"
"        A clock of the batch runtime will be logged in addition to the\n"
"        result of the testrun.\n"
"\n"
"        @param function         pointer to function pointer array\n"
"        @param items            amount of items in functions\n"
"        @returns                negative count of failed tests\n"
"                                positive count of run tests otherwise\n"
" */\n"
"static inline int64_t testrun_parallel(\n"
"        int (*functions[])(),\n"
"        size_t items) {\n"
"\n"
"        if (!functions || items < 1)\n"
"                return 0;\n"
"\n"
"        if (items > INT64_MAX )\n"
"                return 0;\n"
"\n"
"        int64_t c_OK  = 0;\n"
"        int64_t c_NOK = 0;\n"
"\n"
"        clock_t start, end;\n"
"        start = clock();\n"
"\n"
"        int nthreads = 0, tid = 0;\n"
"\n"
"\n"
"        /*\n"
"         *      Use this if you want to reduce or set the number of threads\n"
"         *\n"
"         *      omp_set_dynamic(0);\n"
"         *      omp_set_num_threads(1);\n"
"         */\n"
"\n"
"        #pragma omp parallel for\n"
"        for (size_t i = 0; i < items; i++){\n"
"\n"
"                if (nthreads == 0){\n"
"                        tid = omp_get_thread_num();\n"
"                        if (tid == 0)\n"
"                                nthreads = omp_get_num_threads();\n"
"                }\n"
"\n"
"                if (functions[i] != 0) {\n"
"\n"
"                        if (functions[i]() < 0){\n"
"                                #pragma omp atomic\n"
"                                c_NOK++;\n"
"                        } else {\n"
"                                #pragma omp atomic\n"
"                                c_OK++;\n"
"                        }\n"
"                }\n"
"        }\n"
"\n"
"        testrun_log(\"---------------------------------------------------------\");\n"
"        testrun_log(\"NOTE PARALLEL TESTING\");\n"
"        testrun_log(\"\");\n"
"        testrun_log(\"This version is using OpenMP. Using GCC for compilation \");\n"
"        testrun_log(\"may produce false valgrind output due to use of libomp.\");\n"
"        testrun_log(\"More information is included in docs/valgrind/openMP.\");\n"
"        testrun_log(\"---------------------------------------------------------\");\n"
"\n"
"\n"
"        testrun_log(\"Parallel RUN (%jd) TESTS in %d threads: \"\n"
"                \"success %jd error %jd)\",\n"
"                c_OK + c_NOK, nthreads,\n"
"                c_OK, c_NOK);\n"
"\n"
"        end = clock();\n"
"        testrun_log_clock(start, end);\n"
"        testrun_log(\"\");\n"
"\n"
"        if (c_NOK > 0)\n"
"                return -c_NOK;\n"
"\n"
"        return c_OK;\n"
"}\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Run a bunch of tests serial. This will run all configured\n"
"        tests independently and return the result of the test batch,\n"
"        once all tests are done or the first tests fails, if break_on_error\n"
"        is set.\n"
"\n"
"        A clock of the batch runtime will be logged in addition to the\n"
"        result of the testrun.\n"
"\n"
"        @param function         pointer to function pointer array\n"
"        @param items            amount of items in function\n"
"        @param break_on_error   (true) fail test batch on first error\n"
"                                (false) run all tests before error return\n"
"        @returns                negative count of failed tests\n"
"                                positive count of run tests otherwise\n"
" */\n"
"static inline int64_t testrun_sequential(\n"
"        int (*functions[])(),\n"
"        size_t items,\n"
"        bool break_on_error) {\n"
"\n"
"        if (!functions || items < 1)\n"
"                return 0;\n"
"\n"
"        if (items > INT64_MAX )\n"
"                return 0;\n"
"\n"
"        int64_t c_OK  = 0;\n"
"        int64_t c_NOK = 0;\n"
"\n"
"        clock_t start, end;\n"
"        start = clock();\n"
"\n"
"        for (size_t i = 0; i < items; i++){\n"
"\n"
"                if (functions[i] != 0) {\n"
"\n"
"                        if (functions[i]() < 0) {\n"
"\n"
"                                c_NOK++;\n"
"                                if (break_on_error)\n"
"                                        break;\n"
"\n"
"                        } else {\n"
"\n"
"                                c_OK++;\n"
"\n"
"                        }\n"
"                }\n"
"        }\n"
"\n"
"        testrun_log(\"Serial RUN (%jd) TESTS: success %jd error %jd)\",\n"
"                c_OK + c_NOK,\n"
"                c_OK, c_NOK);\n"
"\n"
"        end = clock();\n"
"        testrun_log_clock(start, end);\n"
"        testrun_log(\"\");\n"
"\n"
"        if (c_NOK > 0)\n"
"                return -c_NOK;\n"
"\n"
"        return c_OK;\n"
"}\n"
"\n"
"/*----------------------------------------------------------------------------*/\n"
"\n"
"/**\n"
"        Run a bunch of configurable parallel and sequential tests serial.\n"
"\n"
"        @param max_parallel     maximum test cases parallel\n"
"        @param max_sequential   maximum test cases sequential\n"
"        @param break_on_error   (true) fail sequential test batch on first error\n"
"                                (false) run all sequential tests\n"
"        @returns                negative count of run tests cased on error\n"
"                                positive count of run tests\n"
" */\n"
"static inline int64_t testrun_run_tests(\n"
"        size_t max_parallel,\n"
"        size_t max_sequential,\n"
"        bool break_on_error) {\n"
"\n"
"        int64_t result_parallel   = 0;\n"
"        int64_t result_sequential = 0;\n"
"        size_t counter_parallel   = 0;\n"
"        size_t counter_sequential = 0;\n"
"\n"
"        if ( (max_parallel == 0) && (max_sequential == 0))\n"
"                return -1;\n"
"\n"
"        // LOAD & RUN test cases\n"
"\n"
"        if (max_parallel > 0) {\n"
"\n"
"                int (*testcases[max_parallel])();\n"
"                testrun_init_testcases(testcases, 0, max_parallel);\n"
"\n"
"                if (!testrun_configure_parallel(\n"
"                        testcases, &counter_parallel, &max_parallel)){\n"
"                        testrun_log_failure(\"Failure configure parallel.\");\n"
"                        return -1;\n"
"                }\n"
"\n"
"                result_parallel = testrun_parallel(testcases, counter_parallel);\n"
"\n"
"                if (result_parallel < 0)\n"
"                        testrun_log(\"Failure testrun parallel run\");\n"
"\n"
"        }\n"
"\n"
"        if (max_sequential > 0) {\n"
"\n"
"                int (*testcases[max_sequential])();\n"
"                testrun_init_testcases(testcases, 0, max_sequential);\n"
"\n"
"                if (!testrun_configure_sequential(\n"
"                        testcases, &counter_sequential, &max_sequential)){\n"
"                        testrun_log_failure(\"Failure configure sequential.\");\n"
"                        return -1;\n"
"                }\n"
"\n"
"                result_sequential = testrun_sequential(\n"
"                        testcases, counter_sequential, break_on_error);\n"
"\n"
"                if (result_sequential < 0)\n"
"                        testrun_log(\"Failure testrun sequential run\");\n"
"\n"
"        }\n"
"\n"
"        if ( (result_parallel < 0) || (result_sequential < 0)) {\n"
"                if ( (counter_parallel + counter_sequential) == 0)\n"
"                        return -1;\n"
"                return ( -1 * (counter_parallel + counter_sequential));\n"
"        }\n"
"\n"
"        return (counter_parallel + counter_sequential);\n"
"}\n"
"\n"
"/**     -----------------------------------------------------------------------\n"
"\n"
"        @example        testrun_assert_example.c\n"
"        @author         Markus Toepfer\n"
"        @date           2017-10-31\n"
"\n"
"        @brief          Example test file using testrun.h\n"
"\n"
"        This example shows assert() style based testing with testrun.h and is\n"
"        build around the testrun_test() macro, which increases a counter which\n"
"        MUST be initialized in a testcluster function.\n"
"\n"
"        -----------------------------------------------------------------------\n"
"\n"
"        @code\n"
"        #include \"../tools/testrun_parallel.h\"\n"
"\n"
"        bool example_function() {\n"
"                return true;\n"
"        }\n"
"        -----------------------------------------------------------------------\n"
"\n"
"        int test_with_assert_function() {\n"
"\n"
"                //     Fail on first testing\n"
"                //\n"
"                //     Fail on first can be implemented using assert,\n"
"                //     or by returning a negative result of the testrun_test\n"
"                //     The following examples do all the same, the will stop\n"
"                //     the whole testrun and report a failure.\n"
"\n"
"                testrun_assert(\n"
"                        example_function() == true, \\\n"
"                        \"Failure: NOK result is true.\"\n"
"                );\n"
"\n"
"                assert(true == example_function());\n"
"                assert(example_function());\n"
"\n"
"                if (!example_function())\n"
"                        return -1;\n"
"\n"
"                // will not be reached in case of error\n"
"                return testrun_log_success();\n"
"        }\n"
"\n"
"        -----------------------------------------------------------------------\n"
"\n"
"        int test_whatever_OK() {\n"
"\n"
"                bool failure = false;\n"
"\n"
"                // Positive result logging\n"
"\n"
"                if (!failure)\n"
"                        return testrun_log_success();\n"
"\n"
"                // will be reached in case of error\n"
"                return testrun_log_error();\n"
"        }\n"
"\n"
"        -----------------------------------------------------------------------\n"
"\n"
"        int test_whatever_NOK() {\n"
"\n"
"                // Failure logging (Don't fail the testrun, just log a failure)\n"
"\n"
"                if (failure)\n"
"                        return testrun_log_error();\n"
"\n"
"                // will not be reached in case of error\n"
"                return testrun_log_success();\n"
"\n"
"        }\n"
"\n"
"        -----------------------------------------------------------------------\n"
"\n"
"        int assert_based_testing() {\n"
"\n"
"                testrun_init();\n"
"\n"
"                testrun_test(test_with_assert_function);\n"
"                testrun_test(test_whatever_OK);\n"
"                testrun_test(test_whatever_NOK);\n"
"\n"
"                return testrun_counter;\n"
"\n"
"        }\n"
"\n"
"        testrun_run(assert_based_testing);\n"
"        @endcode\n"
"\n"
"**/\n"
"/**     -----------------------------------------------------------------------\n"
"\n"
"        @example        testrun_example.c\n"
"        @author         Markus Toepfer\n"
"        @date           2017-11-22\n"
"\n"
"        @brief          Example test file using testrun.h\n"
"\n"
"        This example shows parallel and sequential style based testing\n"
"        with testrun.h and is build around a MACRO set to execute tests in\n"
"        parallel or seqentuial run.\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        @code\n"
"        #include \"../tools/testrun_parallel.h\"\n"
"\n"
"        bool example_function() {\n"
"                return true;\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        int testcase_block1(){\n"
"\n"
"                testrun(example_function());\n"
"                testrun(true);\n"
"                testrun(example_function(), \"second run of function.\");\n"
"\n"
"                return testrun_log_success();\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        int testcase_block2(){\n"
"\n"
"                return testrun_log_success();\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        int testcase_block3(){\n"
"\n"
"                return testrun_log_success();\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        Int testcase_block4(){\n"
"\n"
"               return testrun_log_success();\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        int64_t cluster_tests1(int(*tests[])(), size_t slot, size_t max) {\n"
"\n"
"                testrun_init();                 // create local variables\n"
"                testrun_add(testcase_block1);   // adds block1 to tests[]\n"
"                testrun_add(testcase_block2);   // adds block2 to tests[]\n"
"\n"
"                return testrun_counter;\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        int64_t cluster_tests2(int(*tests[])(), size_t slot, size_t max) {\n"
"\n"
"                testrun_init();                 // create local variables\n"
"                testrun_add(testcase_block3);   // adds block3 to tests[]\n"
"                testrun_add(testcase_block4);   // adds block4 to tests[]\n"
"\n"
"                return testrun_counter;\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        bool testrun_configure_parallel(\n"
"                int (*testcases[])(),\n"
"                size_t * const start,\n"
"                size_t const * const max){\n"
"\n"
"                if (!testcases || !start || !max)\n"
"                        return false;\n"
"\n"
"                if(testrun_add_testcases(\n"
"                        testcases,start, max, cluster_tests1) < 0)\n"
"                        return false;\n"
"\n"
"                return true;\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"\n"
"        bool testrun_configure_sequential(\n"
"                int (*testcases[])(),\n"
"                size_t *const start,\n"
"                size_t const * const max){\n"
"\n"
"                if (!testcases || !start || !max)\n"
"                        return false;\n"
"\n"
"                if(testrun_add_testcases(\n"
"                        testcases,start, max, cluster_tests1) < 0)\n"
"                        return false;\n"
"\n"
"                if(testrun_add_testcases(\n"
"                        testcases,start, max, cluster_tests2) < 0)\n"
"                        return false;\n"
"\n"
"                return true;\n"
"\n"
"        }\n"
"\n"
"        //---------------------------------------------------------------------\n"
"\n"
"        int64_t run_tests() {\n"
"\n"
"                return testrun_run_tests(1000,1000,false);\n"
"        }\n"
"\n"
"        testrun_run(run_tests);\n"
"        @endcode\n"
"\n"
"**/\n"
"\n"
"#endif /* testrun_openmp_h */\n";